# VoPet 프로젝트 기술 스택 보고서

## 1. Android 리소스 시스템 (R 클래스)

### 개요

Android의 `R` 클래스는 리소스 ID를 관리하는 컴파일 타임 생성 클래스입니다. 프로젝트 내 모든 리소스(레이아웃, 이미지, 문자열, 색상 등)에 대한 정수 ID를 제공합니다.

### 사용 예시

```java
// 레이아웃 리소스 참조
setContentView(R.layout.fragment_word_list);

// 뷰 ID로 뷰 찾기
TextView tvVocabulary = view.findViewById(R.id.tvVocabulary);

// 이미지 리소스 설정
imageView.setImageResource(R.drawable.menu_bone);

// 색상 리소스 사용
view.setBackgroundColor(getResources().getColor(R.color.white));
```

### 주요 리소스 타입

- **레이아웃**: `R.layout.*` - XML 레이아웃 파일
- **뷰 ID**: `R.id.*` - XML 내 뷰의 고유 식별자
- **이미지**: `R.drawable.*` - PNG, XML drawable, Lottie 애니메이션
- **색상**: `R.color.*` - 색상 값 정의
- **문자열**: `R.string.*` - 다국어 지원 문자열
- **Raw 리소스**: `R.raw.*` - JSON, Lottie 파일 등

### 특징

- **타입 안전성**: 컴파일 타임에 리소스 존재 여부 검증
- **자동 생성**: 빌드 시 자동으로 생성되며 수동 수정 불가
- **리소스 최적화**: 미사용 리소스 제거로 APK 크기 최적화

---

## 2. 비동기 처리 기술

### 2.1 Thread와 Handler/Looper 패턴

#### 개요

Android에서 메인 스레드(UI 스레드)는 UI 업데이트만 담당하며, 무거운 작업(네트워크, 데이터베이스 등)은 백그라운드 스레드에서 처리해야 합니다. `Thread`와 `Handler`/`Looper`를 조합하여 스레드 간 통신을 구현합니다.

#### 사용 예시

```java
// 백그라운드 스레드에서 데이터베이스 작업 수행
new Thread(() -> {
    try {
        CloudSyncManager cloudSyncManager = new CloudSyncManager(requireContext());
        int count = cloudSyncManager.getNewWordCount(WordListMainActivity.TEMP_USER_ID);

        // UI 스레드로 결과 전달
        new Handler(Looper.getMainLooper()).post(() -> {
            displayBones(boneContainer, count);
        });
    } catch (Exception e) {
        e.printStackTrace();
    }
}).start();
```

#### 핵심 구성 요소

**Thread**

- 백그라운드 작업 실행
- `new Thread(() -> { ... }).start()` 형태로 사용
- Runnable 인터페이스 또는 Lambda 표현식 사용

**Handler**

- 메시지 큐를 통해 스레드 간 통신
- 특정 스레드에 작업을 전달하는 역할

**Looper**

- 메시지 루프를 실행하여 메시지 큐 처리
- `Looper.getMainLooper()`: 메인 스레드의 Looper 반환
- 백그라운드 스레드에서 UI 업데이트를 위해 필수

#### 동작 원리

1. 백그라운드 스레드에서 무거운 작업 수행 (DB 조회, 네트워크 요청 등)
2. 작업 완료 후 `Handler`를 통해 메인 스레드의 `Looper`에 메시지 전달
3. 메인 스레드가 메시지를 받아 UI 업데이트 수행

#### 장점

- Android 기본 API로 추가 라이브러리 불필요
- 명시적인 스레드 제어 가능
- 학습 곡선이 낮음

#### 단점

- 복잡한 비동기 작업 시 코드가 복잡해짐
- 스레드 관리 부담
- 메모리 누수 위험 (Handler 참조 관리 필요)

---

## 3. Room ORM (Object-Relational Mapping)

### 개요

Room은 Android의 공식 SQLite 추상화 라이브러리로, SQLite 데이터베이스를 객체 지향적으로 사용할 수 있게 해줍니다. 컴파일 타임에 SQL 쿼리를 검증하고, 보일러플레이트 코드를 최소화합니다.

### 버전 정보

- **Room Runtime**: 2.6.1
- **Room KTX**: 2.6.1 (Kotlin 확장 함수 지원)
- **Room Compiler**: 2.6.1 (어노테이션 프로세서)

### 핵심 구성 요소

#### 3.1 Entity (엔티티)

데이터베이스 테이블을 나타내는 클래스입니다.

```java
@Entity(tableName = "words",
        foreignKeys = @ForeignKey(entity = WordList.class,
                                 parentColumns = "id",
                                 childColumns = "wordListId",
                                 onDelete = ForeignKey.CASCADE))
public class Word {
    @PrimaryKey(autoGenerate = true)
    public int id;

    public int wordListId;
    public String korean;      // 한국어 의미
    public String foreign;     // 외국어 단어
    public String memo;
    public String example;
    public String pronunciation;
    public String imageUrl;
    public boolean isLiked;

    // 복습 시스템 필드
    public int reviewStage = 0;
    public long nextReviewTime = 0;
    public long lastReviewTime = 0;

    // 동기화 필드
    public String uuid;
    public long updatedAt;
    public boolean isDeleted;
    public boolean isCloud;
}
```

**주요 어노테이션**

- `@Entity`: 테이블 정의
- `@PrimaryKey`: 기본 키 지정
- `@ForeignKey`: 외래 키 관계 정의
- `@Ignore`: 데이터베이스에 저장하지 않을 필드

#### 3.2 DAO (Data Access Object)

데이터베이스 접근 메서드를 정의하는 인터페이스입니다.

```java
@Dao
public interface WordDao {
    // CRUD 작업
    @Insert
    long insert(Word word);

    @Insert
    void insertAll(List<Word> words);

    @Update
    void update(Word word);

    @Delete
    void delete(Word word);

    // 커스텀 쿼리
    @Query("SELECT * FROM words WHERE wordListId = :wordListId ORDER BY id ASC")
    List<Word> getWordsByWordListId(int wordListId);

    @Query("SELECT * FROM words WHERE wordListId = :wordListId AND korean LIKE '%' || :korean || '%'")
    List<Word> searchWordsByKorean(int wordListId, String korean);
}
```

**주요 어노테이션**

- `@Insert`: 삽입 작업
- `@Update`: 수정 작업
- `@Delete`: 삭제 작업
- `@Query`: 커스텀 SQL 쿼리 작성

#### 3.3 Database (데이터베이스)

데이터베이스 인스턴스를 관리하는 추상 클래스입니다.

```java
@Database(entities = { WordList.class, Word.class, User.class },
          version = 11,
          exportSchema = false)
public abstract class VoPetDatabase extends RoomDatabase {

    // DAO 추상 메서드 (컴파일 타임에 Room이 구현)
    public abstract WordListDao wordListDao();
    public abstract WordDao wordDao();
    public abstract UserDao userDao();

    // 싱글톤 패턴으로 인스턴스 관리
    private static volatile VoPetDatabase INSTANCE;

    public static VoPetDatabase getDatabase(final Context context) {
        if (INSTANCE == null) {
            synchronized (VoPetDatabase.class) {
                if (INSTANCE == null) {
                    INSTANCE = Room.databaseBuilder(
                            context.getApplicationContext(),
                            VoPetDatabase.class,
                            "vopet_database"
                    )
                    .allowMainThreadQueries()  // 개발용 (프로덕션에서는 제거)
                    .fallbackToDestructiveMigration()  // 개발용
                    .build();
                }
            }
        }
        return INSTANCE;
    }
}
```

**주요 설정**

- `version`: 데이터베이스 스키마 버전
- `exportSchema`: 스키마 내보내기 여부
- `allowMainThreadQueries()`: 메인 스레드에서 쿼리 허용 (개발용)
- `fallbackToDestructiveMigration()`: 마이그레이션 실패 시 데이터 삭제 후 재생성 (개발용)

### Room의 장점

1. **컴파일 타임 검증**: SQL 쿼리 오류를 컴파일 시점에 발견
2. **타입 안전성**: Java/Kotlin 타입과 데이터베이스 타입 자동 매핑
3. **보일러플레이트 감소**: SQLite 직접 사용 시 필요한 반복 코드 제거
4. **LiveData/Flow 지원**: 반응형 데이터 관찰 가능
5. **관계 처리**: `@Relation` 어노테이션으로 복잡한 관계 자동 처리

### 프로젝트에서의 활용

**데이터 모델**

- `Word`: 단어 정보 (외국어, 한국어, 이미지, 좋아요 등)
- `WordList`: 단어장 정보 (이름, 생성일, 고정 여부 등)
- `User`: 사용자 정보 (경험치, 레벨, 로그인 시간 등)

**주요 기능**

- 단어 CRUD 작업
- 단어장 관리
- 사용자 경험치 시스템
- 복습 시스템 (reviewStage, nextReviewTime)
- 클라우드 동기화 (uuid, updatedAt, isCloud)

---

## 4. Retrofit (HTTP 클라이언트)

### 개요

Retrofit은 Square에서 개발한 타입 안전한 HTTP 클라이언트 라이브러리입니다. RESTful API와의 통신을 간편하게 처리할 수 있게 해줍니다.

### 버전 정보

- **Retrofit**: 2.9.0
- **Gson Converter**: 2.9.0 (JSON 변환)
- **OkHttp**: 4.12.0 (HTTP 클라이언트)
- **OkHttp Logging Interceptor**: 4.12.0 (네트워크 로깅)

### 핵심 구성 요소

#### 4.1 API 서비스 인터페이스

```java
public interface WordApiService {
    // GET 요청: 사용자의 모든 단어 조회
    @GET("api/words")
    Call<List<WordResponse>> getWordsByUserId(@Query("user_id") String userId);

    // GET 요청: 증분 동기화 (변경된 단어만 조회)
    @GET("api/words/since")
    Call<List<WordResponse>> getWordsSince(
            @Query("user_id") String userId,
            @Query("since") long timestamp);

    // GET 요청: 새 단어 개수 조회
    @GET("api/words/count")
    Call<WordCountResponse> getNewWordCount(
            @Query("user_id") String userId,
            @Query("since") long timestamp);

    // POST 요청: 단어 생성
    @POST("api/words")
    Call<WordResponse> createWord(@Body WordRequest request);

    // PUT 요청: 단어 수정
    @PUT("api/words/{id}")
    Call<WordResponse> updateWord(@Path("id") Long id, @Body WordRequest request);

    // DELETE 요청: 단어 삭제
    @DELETE("api/words/{id}")
    Call<Void> deleteWord(@Path("id") Long id);
}
```

**주요 어노테이션**

- `@GET`, `@POST`, `@PUT`, `@DELETE`: HTTP 메서드 지정
- `@Query`: 쿼리 파라미터
- `@Path`: URL 경로 변수
- `@Body`: 요청 본문 (JSON 변환)

#### 4.2 Retrofit 클라이언트 설정

```java
public class ApiClient {
    private static final String BASE_URL = BuildConfig.BASE_URL;
    private static Retrofit retrofit;

    public static Retrofit getRetrofitInstance() {
        if (retrofit == null) {
            // HTTP 로깅 인터셉터
            HttpLoggingInterceptor logging = new HttpLoggingInterceptor();
            logging.setLevel(HttpLoggingInterceptor.Level.BODY);

            // OkHttp 클라이언트 설정
            OkHttpClient client = new OkHttpClient.Builder()
                    .addInterceptor(logging)
                    .connectTimeout(30, TimeUnit.SECONDS)
                    .readTimeout(30, TimeUnit.SECONDS)
                    .writeTimeout(30, TimeUnit.SECONDS)
                    .build();

            // Retrofit 빌더
            retrofit = new Retrofit.Builder()
                    .baseUrl(BASE_URL)
                    .client(client)
                    .addConverterFactory(GsonConverterFactory.create())
                    .build();
        }
        return retrofit;
    }

    public static WordApiService getApiService() {
        return getRetrofitInstance().create(WordApiService.class);
    }
}
```

### Retrofit의 장점

1. **타입 안전성**: 인터페이스 기반으로 컴파일 타임 검증
2. **간결한 코드**: 어노테이션만으로 API 정의
3. **자동 변환**: Gson을 통한 JSON ↔ 객체 자동 변환
4. **인터셉터 지원**: 요청/응답 로깅, 인증 토큰 추가 등
5. **동시성 처리**: OkHttp 기반의 효율적인 네트워크 처리

### 프로젝트에서의 활용

**클라우드 동기화**

- 초기 동기화: 사용자의 모든 단어 다운로드
- 증분 동기화: 마지막 동기화 이후 변경된 단어만 조회
- 뱃지 표시: 새 단어 개수만 조회하여 UI 업데이트

**데이터 흐름**

1. 로컬 Room 데이터베이스에 단어 저장
2. Retrofit을 통해 서버에 동기화
3. 서버 응답을 DTO로 변환 후 Room에 저장

---

## 5. 백엔드 연동 아키텍처

### 5.1 전체 구조 개요

VoPet 프로젝트는 **클라이언트-서버 아키텍처**를 채택하여 로컬 데이터베이스와 클라우드 서버 간의 동기화를 구현합니다.

```
┌─────────────────────────────────────────────────────────────┐
│                    Android 클라이언트                         │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌──────────────┐      ┌──────────────┐                     │
│  │   UI Layer   │      │  Sync Layer  │                     │
│  │ (Fragments)  │◄────►│(CloudSyncMgr)│                     │
│  └──────────────┘      └──────┬───────┘                     │
│         │                     │                             │
│         │                     │                             │
│         ▼                     ▼                             │
│  ┌──────────────┐      ┌──────────────┐                     │
│  │  Local DB    │      │  API Layer    │                     │
│  │   (Room)     │◄────►│  (Retrofit)   │                     │
│  └──────────────┘      └──────┬───────┘                     │
│                                 │                             │
└─────────────────────────────────┼─────────────────────────────┘
                                  │
                                  │ HTTP/REST
                                  │
┌─────────────────────────────────▼─────────────────────────────┐
│                    백엔드 서버 (RESTful API)                   │
│                                                               │
│  ┌──────────────┐      ┌──────────────┐                     │
│  │  API Server  │      │  Database    │                     │
│  │  (Spring/    │◄────►│  (MySQL/     │                     │
│  │   Express)   │      │   PostgreSQL)│                     │
│  └──────────────┘      └──────────────┘                     │
└─────────────────────────────────────────────────────────────┘
```

### 5.2 데이터 계층 구조

프로젝트는 **3계층 데이터 구조**를 사용하여 클라이언트와 서버 간의 데이터 변환을 관리합니다.

#### 5.2.1 Entity (로컬 데이터베이스 모델)

Android 앱 내부에서 사용하는 데이터 모델입니다.

```java
@Entity(tableName = "words")
public class Word {
    @PrimaryKey(autoGenerate = true)
    public int id;                    // 로컬 DB 자동 생성 ID

    public int wordListId;             // Android 전용: 단어장 ID
    public String korean;              // 한국어 의미
    public String foreign;            // 외국어 단어
    public String imageUrl;            // Android 전용: 이미지 경로
    public boolean isLiked;            // Android 전용: 좋아요 상태

    // 동기화 필드
    public String uuid;                 // 서버와 동기화용 고유 ID
    public long updatedAt;             // 마지막 수정 시간
    public boolean isCloud;            // 클라우드 단어 여부
    public boolean isDeleted;           // Soft Delete 플래그
}
```

**특징**

- Android UI/UX에 최적화된 필드 구조
- 로컬 전용 필드 포함 (wordListId, imageUrl, isLiked)
- 동기화를 위한 메타데이터 필드 포함

#### 5.2.2 DTO (Data Transfer Object)

클라이언트와 서버 간 데이터 전송에 사용되는 객체입니다.

**WordRequest (요청 DTO)**

```java
@Getter @Setter
public class WordRequest {
    // 백엔드 필드 (API와 호환)
    private String userId;
    private String word;              // 외국어 단어
    private String translation;       // 한국어 의미
    private String pronunciation;
    private String example;

    // Android 전용 필드 (nullable)
    private Integer wordListId;
    private String imageUrl;
    private Boolean isLiked;
}
```

**WordResponse (응답 DTO)**

```java
@Getter @Setter
public class WordResponse {
    // 백엔드 필드
    private Long id;                  // 서버 생성 ID
    private String word;
    private String translation;
    private String pronunciation;
    private String example;
    private String createdAt;         // ISO 8601 형식
    private String updatedAt;

    // Android 전용 필드 (nullable)
    private Integer wordListId;
    private String imageUrl;
    private Boolean isLiked;
}
```

**특징**

- 백엔드 API 스펙과 정확히 일치
- Android 전용 필드는 nullable로 처리하여 호환성 유지
- JSON 직렬화/역직렬화 최적화

#### 5.2.3 Mapper (데이터 변환 계층)

Entity와 DTO 간 변환을 담당하는 매퍼 클래스입니다.

```java
public class WordMapper {
    // Entity → Request DTO (서버 전송용)
    public static WordRequest toRequest(Word word, String userId) {
        WordRequest request = new WordRequest();
        request.setUserId(userId);
        request.setWord(word.foreign);           // foreign → word
        request.setTranslation(word.korean);    // korean → translation
        request.setWordListId(word.wordListId);
        request.setImageUrl(word.imageUrl);
        request.setIsLiked(word.isLiked);
        return request;
    }

    // Response DTO → Entity (서버 응답 저장용)
    public static Word toEntity(WordResponse response, int wordListId) {
        Word word = new Word();
        word.foreign = response.getWord();           // word → foreign
        word.korean = response.getTranslation();     // translation → korean
        word.wordListId = wordListId;
        word.imageUrl = response.getImageUrl();
        word.isLiked = response.getIsLiked() != null ? response.getIsLiked() : false;
        word.isCloud = true;                        // 서버에서 온 데이터 표시
        return word;
    }
}
```

**역할**

- 필드명 변환: `foreign` ↔ `word`, `korean` ↔ `translation`
- 타입 변환: `int` ↔ `Long`, `boolean` ↔ `Boolean`
- 기본값 처리: null 안전성 보장

### 5.3 클라우드 동기화 전략

#### 5.3.1 동기화 유형

**1. 초기 동기화 (Full Sync)**

- **시점**: 앱 최초 설치 또는 마지막 동기화 시간이 없는 경우
- **API**: `GET /api/words?user_id={userId}`
- **동작**: 사용자의 모든 단어를 서버에서 다운로드

```java
public List<WordResponse> fetchCloudWords(String userId) {
    Call<List<WordResponse>> call = apiService.getWordsByUserId(userId);
    Response<List<WordResponse>> response = call.execute();

    if (response.isSuccessful() && response.body() != null) {
        return response.body();  // 전체 단어 목록 반환
    }
    return new ArrayList<>();
}
```

**2. 증분 동기화 (Incremental Sync)**

- **시점**: 앱 실행 시 또는 주기적 동기화
- **API**: `GET /api/words/since?user_id={userId}&since={timestamp}`
- **동작**: 마지막 동기화 이후 변경된 단어만 다운로드
- **장점**: 네트워크 트래픽 90% 절감

```java
public List<WordResponse> fetchCloudWordsSince(String userId) {
    long lastSyncTime = getLastSyncTime(userId);

    if (lastSyncTime == 0) {
        return fetchCloudWords(userId);  // 초기 동기화로 폴백
    }

    Call<List<WordResponse>> call = apiService.getWordsSince(userId, lastSyncTime);
    Response<List<WordResponse>> response = call.execute();

    if (response.isSuccessful() && response.body() != null) {
        return response.body();  // 변경된 단어만 반환
    }
    return new ArrayList<>();
}
```

**3. 뱃지용 개수 조회 (Count Only)**

- **시점**: UI 뱃지 업데이트 (예: 인트로 화면)
- **API**: `GET /api/words/count?user_id={userId}&since={timestamp}`
- **동작**: 새 단어 개수만 조회 (전체 데이터 다운로드 불필요)
- **장점**: 네트워크 트래픽 최소화 (50KB → 4 bytes)

```java
public int getNewWordCount(String userId) {
    long lastSyncTime = getLastSyncTime(userId);
    Call<WordCountResponse> call = apiService.getNewWordCount(userId, lastSyncTime);
    Response<WordCountResponse> response = call.execute();

    if (response.isSuccessful() && response.body() != null) {
        return response.body().getCount();  // 개수만 반환
    }
    return 0;
}
```

#### 5.3.2 CloudSyncManager 구조

**역할**

- 클라우드와 로컬 DB 간의 모든 동기화 로직 중앙 관리
- Rate Limiting (동기화 쿨다운)
- SharedPreferences를 통한 마지막 동기화 시간 관리

```java
public class CloudSyncManager {
    private final WordApiService apiService;  // Retrofit API
    private final WordDao wordDao;            // Room DAO

    // Rate Limiting
    private static final long SYNC_COOLDOWN_MS = 1000;  // 1초 쿨다운

    // 마지막 동기화 시간 관리 (SharedPreferences)
    public long getLastSyncTime(String userId) {
        SharedPreferences prefs = context.getSharedPreferences(
            "cloud_sync_pref", Context.MODE_PRIVATE);
        return prefs.getLong("last_sync_" + userId, 0);
    }

    // 클라우드 단어를 로컬 DB에 저장
    public int importToLocalWordList(
            List<WordResponse> cloudWords,
            int localWordListId,
            String userId) {

        int importedCount = 0;
        for (WordResponse response : cloudWords) {
            // DTO → Entity 변환
            Word word = WordMapper.toEntity(response, localWordListId);

            // UUID 설정 (서버 ID 기반)
            if (word.uuid == null || word.uuid.isEmpty()) {
                word.uuid = userId + "_" + response.getId();
            }
            word.isCloud = true;  // 클라우드 단어 표시

            // 로컬 DB에 저장
            wordDao.insert(word);
            importedCount++;
        }

        // 동기화 시간 업데이트
        if (importedCount > 0) {
            saveLastSyncTime(userId);
        }

        return importedCount;
    }
}
```

### 5.4 데이터 흐름도

#### 5.4.1 클라우드 → 로컬 (다운로드)

```
1. 사용자 앱 실행
   │
   ▼
2. CloudSyncManager.fetchCloudWordsSince(userId)
   │
   ▼
3. Retrofit API 호출
   GET /api/words/since?user_id=xxx&since=1234567890
   │
   ▼
4. 서버 응답: List<WordResponse> (JSON)
   │
   ▼
5. WordMapper.toEntity() - DTO → Entity 변환
   │
   ▼
6. Room Database에 저장 (wordDao.insert())
   │
   ▼
7. SharedPreferences에 동기화 시간 저장
   │
   ▼
8. UI 업데이트 (RecyclerView, 뱃지 등)
```

#### 5.4.2 로컬 → 클라우드 (업로드)

```
1. 사용자가 단어 추가/수정
   │
   ▼
2. Room Database에 저장 (wordDao.insert/update)
   │
   ▼
3. WordMapper.toRequest() - Entity → DTO 변환
   │
   ▼
4. Retrofit API 호출
   POST /api/words 또는 PUT /api/words/{id}
   │
   ▼
5. 서버 응답: WordResponse
   │
   ▼
6. 로컬 DB 업데이트 (서버 ID, updatedAt 등)
```

### 5.5 동기화 상태 관리

#### 5.5.1 SharedPreferences 활용

마지막 동기화 시간을 SharedPreferences에 저장하여 증분 동기화를 가능하게 합니다.

```java
// 동기화 시간 저장
private void saveLastSyncTime(String userId) {
    SharedPreferences prefs = context.getSharedPreferences(
        "cloud_sync_pref", Context.MODE_PRIVATE);
    prefs.edit()
        .putLong("last_sync_" + userId, System.currentTimeMillis())
        .apply();
}

// 동기화 시간 조회
public long getLastSyncTime(String userId) {
    SharedPreferences prefs = context.getSharedPreferences(
        "cloud_sync_pref", Context.MODE_PRIVATE);
    return prefs.getLong("last_sync_" + userId, 0);
}
```

#### 5.5.2 Rate Limiting

과도한 API 호출을 방지하기 위한 쿨다운 메커니즘입니다.

```java
public boolean canSync(String userId) {
    long lastSyncTime = getLastSyncTime(userId);
    long now = System.currentTimeMillis();
    return (now - lastSyncTime) >= SYNC_COOLDOWN_MS;
}
```

### 5.6 백엔드 API 스펙

#### RESTful API 엔드포인트

| 메서드 | 엔드포인트         | 용도         | 파라미터                          |
| ------ | ------------------ | ------------ | --------------------------------- |
| GET    | `/api/words`       | 초기 동기화  | `user_id`                         |
| GET    | `/api/words/since` | 증분 동기화  | `user_id`, `since`                |
| GET    | `/api/words/count` | 새 단어 개수 | `user_id`, `since`                |
| GET    | `/api/words/{id}`  | 단어 조회    | `id` (Path)                       |
| POST   | `/api/words`       | 단어 생성    | `WordRequest` (Body)              |
| PUT    | `/api/words/{id}`  | 단어 수정    | `id` (Path), `WordRequest` (Body) |
| DELETE | `/api/words/{id}`  | 단어 삭제    | `id` (Path)                       |

#### 응답 형식

**성공 응답 (200 OK)**

```json
{
  "id": 123,
  "word": "apple",
  "translation": "사과",
  "pronunciation": "애플",
  "example": "I like apples",
  "createdAt": "2024-01-01T00:00:00Z",
  "updatedAt": "2024-01-02T00:00:00Z",
  "wordListId": 1,
  "imageUrl": "drawable/apple",
  "isLiked": false
}
```

**에러 응답 (4xx/5xx)**

```json
{
  "error": "Invalid user_id",
  "message": "User not found",
  "code": 404
}
```

### 5.7 오프라인 지원 전략

#### 로컬 우선 정책

1. **오프라인 모드**: 네트워크 없이도 로컬 DB에서 데이터 조회 가능
2. **동기화 대기열**: 오프라인 중 변경사항을 큐에 저장, 온라인 시 일괄 동기화
3. **충돌 해결**: `updatedAt` 타임스탬프 기반 최신 데이터 우선 적용

#### 데이터 일관성

- **UUID 기반 중복 방지**: 서버 ID와 로컬 UUID를 매핑하여 중복 저장 방지
- **Soft Delete**: `isDeleted` 플래그로 삭제된 데이터 추적
- **isCloud 플래그**: 클라우드 단어와 로컬 단어 구분

### 5.8 보안 고려사항

#### API 인증 (향후 구현)

- 현재: `userId`를 쿼리 파라미터로 전달 (개발 단계)
- 향후: OAuth 2.0 / JWT 토큰 기반 인증
- OkHttp Interceptor를 통한 자동 토큰 추가

#### 데이터 암호화

- **전송**: HTTPS (TLS 1.2+)
- **저장**: Room 데이터베이스는 기본적으로 암호화되지 않음 (민감 정보 주의)

---

## 6. 기타 주요 라이브러리

### 5.1 Lottie (애니메이션)

- **버전**: 6.1.0
- **용도**: JSON 기반 벡터 애니메이션 재생
- **사용 예시**: 반려어휘 강아지 애니메이션 (`happy_dog.lottie`)

### 5.2 Material Design Components

- **버전**: 1.13.0
- **용도**: Google Material Design 컴포넌트 사용
- **주요 컴포넌트**: CardView, MaterialAlertDialog 등

### 5.3 Lombok

- **버전**: 1.18.30
- **용도**: 보일러플레이트 코드 자동 생성
- **주요 어노테이션**: `@Getter`, `@Setter`, `@NoArgsConstructor`, `@AllArgsConstructor`

### 5.4 ThreeTenABP (날짜/시간 처리)

- **버전**: 1.4.6
- **상태**: 의존성으로 추가되어 있으나 현재 코드에서는 사용되지 않음
- **용도**: Java 8 Time API (LocalDateTime 등) Android 지원
- **현재 프로젝트의 날짜/시간 처리 방식**:
  - `System.currentTimeMillis()`를 사용하여 `long` 타입의 타임스탬프 저장
  - 복잡한 날짜/시간 연산이 필요하지 않아 ThreeTenABP를 사용하지 않음
  - 백엔드와의 통신 시 ISO 8601 문자열 형식으로 날짜 전송

---

## 6. 아키텍처 패턴

### 6.1 싱글톤 패턴

데이터베이스와 API 클라이언트 인스턴스를 앱 전체에서 하나만 유지합니다.

```java
// VoPetDatabase 싱글톤
private static volatile VoPetDatabase INSTANCE;
public static VoPetDatabase getDatabase(final Context context) {
    if (INSTANCE == null) {
        synchronized (VoPetDatabase.class) {
            if (INSTANCE == null) {
                INSTANCE = Room.databaseBuilder(...).build();
            }
        }
    }
    return INSTANCE;
}
```

### 6.2 Mapper 패턴

Entity와 DTO 간 변환을 담당하는 Mapper 클래스를 사용합니다.

```java
public class WordMapper {
    // Entity → DTO 변환
    public static WordRequest toRequest(Word word, String userId) { ... }

    // DTO → Entity 변환
    public static Word toEntity(WordRequest request, int wordListId) { ... }
}
```

---

## 7. 프로젝트 구조 요약

### 7.1 디렉토리 구조

```
app/src/main/java/com/example/vopet/
├── api/                    # 백엔드 API 통신 계층
│   ├── ApiClient.java      # Retrofit 클라이언트 설정 (싱글톤)
│   └── WordApiService.java # RESTful API 인터페이스 정의
│
├── database/               # 로컬 데이터베이스 계층 (Room ORM)
│   ├── VoPetDatabase.java  # Database 클래스 (싱글톤)
│   ├── Word.java           # Entity: 단어 데이터 모델
│   ├── WordDao.java        # DAO: 단어 CRUD 작업
│   ├── WordList.java       # Entity: 단어장 데이터 모델
│   ├── WordListDao.java    # DAO: 단어장 CRUD 작업
│   ├── User.java           # Entity: 사용자 데이터 모델
│   └── UserDao.java        # DAO: 사용자 CRUD 작업
│
├── dto/                    # 데이터 전송 객체 계층
│   ├── WordRequest.java    # 서버 요청 DTO (POST/PUT)
│   ├── WordResponse.java   # 서버 응답 DTO (GET)
│   ├── WordCountResponse.java # 단어 개수 응답 DTO
│   └── WordMapper.java     # Entity ↔ DTO 변환 매퍼
│
├── sync/                   # 클라우드 동기화 계층
│   └── CloudSyncManager.java # 동기화 로직 중앙 관리
│       - 초기/증분 동기화
│       - Rate Limiting
│       - SharedPreferences 관리
│
├── fragments/              # UI 프레젠테이션 계층
│   ├── WordListFragment.java      # 단어 학습 화면
│   ├── StreakIntroFragment.java   # 인트로 화면
│   ├── CloudSyncFragment.java     # 동기화 화면
│   ├── AddWordFragment.java       # 단어 추가 화면
│   └── ...
│
└── utils/                  # 유틸리티 계층
    └── ExpManager.java     # 경험치 관리 (싱글톤)
```

### 7.2 계층별 역할

#### Presentation Layer (UI 계층)

- **역할**: 사용자 인터페이스 및 사용자 상호작용 처리
- **구성**: Fragments, Activities
- **책임**:
  - 사용자 입력 처리
  - UI 상태 관리
  - 비즈니스 로직 호출

#### Business Logic Layer (비즈니스 로직 계층)

- **역할**: 애플리케이션의 핵심 비즈니스 로직 처리
- **구성**: CloudSyncManager, ExpManager
- **책임**:
  - 동기화 로직
  - 경험치 계산
  - 데이터 검증

#### Data Access Layer (데이터 접근 계층)

- **역할**: 데이터 저장 및 조회
- **구성**: Room DAO, Retrofit API Service
- **책임**:
  - 로컬 DB CRUD 작업
  - 네트워크 API 호출
  - 데이터 변환 (Mapper)

#### Data Layer (데이터 계층)

- **역할**: 데이터 저장소
- **구성**: Room Database, SharedPreferences, 백엔드 서버
- **책임**:
  - 영구 데이터 저장
  - 데이터 동기화
  - 캐싱

### 7.3 데이터 흐름 패턴

```
┌─────────────────────────────────────────────────────────┐
│                    사용자 액션                           │
│              (단어 추가, 동기화 등)                       │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│              Presentation Layer                         │
│         (Fragments, Activities)                        │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│            Business Logic Layer                         │
│    (CloudSyncManager, ExpManager)                       │
└────────────────────┬────────────────────────────────────┘
                     │
         ┌──────────┴──────────┐
         │                      │
         ▼                      ▼
┌─────────────────┐    ┌─────────────────┐
│  Local Database  │    │  Backend API    │
│   (Room ORM)     │    │   (Retrofit)    │
└─────────────────┘    └─────────────────┘
         │                      │
         └──────────┬───────────┘
                    │
                    ▼
         ┌─────────────────┐
         │  Data Mapper    │
         │ (Entity ↔ DTO)  │
         └─────────────────┘
```

---

## 8. 결론

### 8.1 기술 스택 요약

VoPet 프로젝트는 다음과 같은 기술 스택을 활용하여 구현되었습니다:

#### 프론트엔드 (Android 클라이언트)

1. **Android 리소스 시스템 (R 클래스)**: 타입 안전한 리소스 관리
2. **Thread/Handler/Looper**: 명시적인 비동기 처리
3. **Room ORM**: 타입 안전한 로컬 데이터베이스 관리
4. **Retrofit**: 타입 안전한 HTTP 클라이언트
5. **Lottie**: 벡터 애니메이션 지원
6. **Material Design**: 일관된 UI/UX 제공

#### 백엔드 연동

1. **RESTful API**: 표준 HTTP 메서드를 활용한 서버 통신
2. **DTO 패턴**: 클라이언트-서버 간 데이터 구조 분리
3. **Mapper 패턴**: Entity와 DTO 간 자동 변환
4. **증분 동기화**: 효율적인 데이터 동기화 전략
5. **오프라인 지원**: 로컬 우선 정책으로 네트워크 없이도 동작

### 8.2 아키텍처 특징

#### 계층 분리

- **명확한 책임 분리**: 각 계층이 독립적으로 동작하며 유지보수 용이
- **의존성 역전**: 상위 계층이 하위 계층에 의존하되, 인터페이스를 통한 느슨한 결합

#### 확장성

- **싱글톤 패턴**: 데이터베이스, API 클라이언트 등 공유 리소스 효율적 관리
- **Mapper 패턴**: 백엔드 API 변경 시 클라이언트 코드 최소 수정

#### 성능 최적화

- **증분 동기화**: 전체 데이터 대신 변경된 데이터만 전송 (트래픽 90% 절감)
- **로컬 캐싱**: Room 데이터베이스로 오프라인 지원 및 빠른 데이터 접근
- **Rate Limiting**: 과도한 API 호출 방지

### 8.3 프로젝트의 강점

1. **타입 안전성**: Room과 Retrofit의 컴파일 타임 검증으로 런타임 오류 최소화
2. **유지보수성**: 계층 분리와 명확한 구조로 코드 이해 및 수정 용이
3. **확장성**: 새로운 기능 추가 시 기존 구조를 크게 변경하지 않고 확장 가능
4. **사용자 경험**: 오프라인 지원과 빠른 로컬 데이터 접근으로 끊김 없는 사용자 경험 제공

### 8.4 향후 개선 방향

1. **인증 시스템**: OAuth 2.0 / JWT 토큰 기반 인증 구현
2. **실시간 동기화**: WebSocket 또는 Server-Sent Events를 통한 실시간 업데이트
3. **충돌 해결**: 더 정교한 충돌 해결 전략 (3-way merge 등)
4. **캐싱 전략**: 더 효율적인 캐싱 및 무효화 전략
5. **에러 처리**: 네트워크 오류, 타임아웃 등에 대한 더 나은 사용자 피드백

이러한 기술들의 조합으로 안정적이고 유지보수가 용이하며, 확장 가능한 Android 애플리케이션을 구현할 수 있었습니다.
